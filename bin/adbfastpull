#!/usr/bin/perl
###############################################################################
# Copyright 2013 Motorola Mobility LLC. Part of the Trailmix project.
# CONFIDENTIAL. AUTHORIZED USE ONLY. DO NOT REDISTRIBUTE.
#
# Utility to pull all the data directories produced by the android player app
# in the specified device. This is meant to be called primarily by
# adbfastpullmulti, should not need to call it directly. Use -h for usage.
#
# Note:
# dataset in: '/data/data/com.motorola.atap.tangomapper/files'
#
###############################################################################

# Import POSIX to expose floor().
use POSIX;
# Import high resolution time functions.
use Time::HiRes qw( time );
# Import Getopt command line parsing functions.
use Getopt::Std;
# Define and hook handler for INT signal.
use sigtrap 'handler' => \&myhand, 'INT';
# Import locking functions.
use Fcntl qw/ :flock /;

# Number of threads used by adb pull.
use constant NUM_THREADS => 10;
# Substring returned by adb pull when a file/dir is missing
use constant PULL_ERROR => "does not exist";
# Substring returned by adb pull when a file/dir is missing
use constant NO_SUCH_FILE => "No such file";
# Default path in which the andoid player stores data.
$app_path = "/data/data/com.motorola.atap.tangomapper/files/";
$app_path_pure = "/data/data/com.motorola.atap.tangomapper/files/";
# Superframes dir name.
$sf_dir_name = "superframes";
# Note file name.
$notes_name = "notes.txt";
# Temporary directory name.
$tmp_dir = "tmp";
# Path to the calibration files.
$calibration_file = "/sdcard/calibration.xml";

my %args;
getopts('o:n:svhf:',\%args);

if ($args{h} || (scalar(@ARGV) != 1)) {
  usage();
  exit(-1);
} else {
  $dataset = $ARGV[0];
  $app_path = $app_path . $dataset
}

my $dest_path = "./";
if ($args{o}) {
  $dest_path = $args{o};
} else {
  $dest_path = "~/data/peanut/" . $dataset;
  printf("saving to default directory\n");
}

# Remove any leading /
if (substr($dest_path,-1,1) eq "/"){
  chop($dest_path);
}

my $make_video = 0;
if ($args{v}) {
  $make_video = 1;
}

my $note = "";
if ($args{n}) {
  $note = $args{n};
}


# Save the starting time in order to time the script and estimating the
# transfer speed.
my $start = time();

# Use adb to get the serial numbers of all the devices connected to the
# system.
my $adb_str = `adb devices`;

my @adb_str_lines = split('\n', $adb_str);
my $found = 0;
foreach my $line (@adb_str_lines) {
  my $is_a_device = (($line =~ /([a-z0-9]{8})\s+device/)
                     || ($line =~ /([a-z0-9]{6})\s+device/));
  if ($is_a_device) {
    ++$found;
  }
}

if (!$found) {
  print("No devices found. Please ensure your device is connected!");
  exit(-1);
}
print("Downloading data...\n");

# Define the global lists that will be populated with source and
# destination files.
@src_file_names = ();
@dest_file_names = ();
@datasets_dest_dirs = ();
$total_size = 0;
my $device = $dataset;

print("Listing files in $app_path...\n");
populateInAndOutLists($app_path, $dest_path, $note);


# Fork NUM_THREADS threads each of which copies num_files/NUM_THREADS files
# if there are files to copy.
if ( scalar(@src_file_names) > 1) {
  @childs = ();
  for (my $thread_count = 0; $thread_count < NUM_THREADS; ++$thread_count) {
    my $pid = fork();
    if ($pid) {
      push(@childs, $pid);
    } elsif ($pid == 0) {
      subPull($thread_count, $device);
      exit(0);
    } else {
      die ("Error: couldn't fork $!\n");
    }
  }
  # Wait for threads to complete.
  foreach $child (@childs) {
    my $tmp = waitpid($child, 0);
  }
  @childs = ();
} else {
 printf("No files found under folder \"$dataset\".\n");
 my $possible_folders = `adb shell ls $app_path_pure | grep -v maps`;
 printf("Datasets available on device:\n%s", $possible_folders);
 exit(-1);
}

# Compute and print out average transfer rate.
my $end = time();
printf("Transferred %.2fMb in %.2fs  %.2fMB/s\n", ($total_size/1024),
        $end - $start, ($total_size/1024)/($end - $start));

if ($args{v}) {
  $which_mencoder = `which mencoder`;
  $which_convert = `which convert`;

  if (($which_mencoder eq "") || ($which_convert eq "")) {
    print("Mencoder and imagemagick are not installed in the system, ".
          "video file will not be generated.\n");
  } else {
    # Fork N threads one for each video to be encoded.
    $nthreads = (NUM_THREADS, scalar(@datasets_dest_dirs))[NUM_THREADS
                 > scalar(@datasets_dest_dirs)];

    for (my $thread_count = 0; $thread_count < $nthreads; ++$thread_count) {
      my $pid = fork();
      if ($pid) {
        push(@childs, $pid);
      } elsif ($pid == 0) {
        subEncode($thread_count,$nthreads,$device);
        exit(0);
      } else {
        die("coudn't fork: $!\n");
      }
    }

    # Wait for threads to complete.
    foreach $child (@childs) {
      my $tmp = waitpid($child, 0);
    }
    @childs = ();
  }
}


# Handles INT signal.
sub myhand
{
  print("\n caught $SIG{INT}",@_,"\n");
  kill 9, @childs;
  foreach $child (@childs) {
    my $tmp = waitpid($child, 0);
  }
  die("Quit");
}


# List directory content recursively and
# populate input and output file lists accordingly.
sub populateInAndOutLists {
  my $cur_dir = shift;
  my $dest_dir = shift;
  my $note = shift;

  $ls_output = `adb shell ls -l $cur_dir`;
  print("ls output $ls_output");

  my @lines = split("\n", $ls_output);

  my @sub_dirs = ();

  foreach my $line (@lines) {
    $line =~ s/\R//g;
    my @parts = split(" ", $line);
    my $permissions = $parts[0];

    if (substr($permissions,0,1) eq "d") {
      # The input line is a directory.
      push(@sub_dirs, $parts[5]);
    } else {
      # The input line is a file.
      # TODO(renzodenardi): remove hack to files on the base dir
      # if($cur_dir ne $app_path){
        push(@src_file_names, $cur_dir."/".$parts[6]);
        push(@dest_file_names, $dest_dir."/".$parts[6]);
        $total_size = $total_size + $parts[3]/1024;
      # }
    }
  }

  if (scalar(@sub_dirs) == 0) {
    # Done!
    return ;
  } else {
    # Recurse into subdirs.
    foreach my $sub_dir (@sub_dirs) {
      if ($cur_dir ne $app_path) {
        populateInAndOutLists($cur_dir."/".$sub_dir, $dest_dir."/".$sub_dir);
      } else {
        # The root of the data directory is processed differently.
        my $process_subdir = 0;
        if ($note ne ""){
          my $pull_notes_output =
             `adb pull $cur_dir/$sub_dir/$notes_name /$tmp_dir 2>&1`;
          if (index($pull_notes_output, PULL_ERROR) != -1) {
            $process_subdir = 0;
          } else {
            open($note_file, "<", "/$tmp_dir/$notes_name");
            while(<$note_file>) {
              chomp;
              if (index($_, $note) != -1) {
                $process_subdir = 1;
              }
            }
            unlink("/$tmp_dir/$notes_name");
          }
        } else {
          $process_subdir = 1;
        }

        if ($process_subdir) {
          push(@datasets_dest_dirs, $sub_dir);
          populateInAndOutLists($cur_dir."/".$sub_dir, $dest_dir."/".
                                $sub_dir);
          # TODO: get rid of the following ad have the player copying
          # cal files into the data folder.
          $cf = 0;
          if (index(`adb shell ls $calibration_file`,
                    NO_SUCH_FILE) == -1) {
            push(@src_file_names, $calibration_file);
            $idx = rindex($calibration_file,"/") + 1;
            push(@dest_file_names, $dest_dir."/".$sub_dir
                 ."/".substr($calibration_file,$idx));
            $cf = 1;
          }
          if ($cf == 0) {
            my $s = "Warning: calibration file not present";
            print($s."\n");
          }
        }
      }
    }
  }
}


# Worker subroutine that pulls a chunck of files from the device using adb.
# Copied files are compared against originals using their md5 signature.
sub subPull {
  my $thread_count = shift;
  my $device = shift;

  my $share = floor(scalar(@src_file_names)/NUM_THREADS);
  my $sidx = ($thread_count * $share);

  if ($thread_count == (NUM_THREADS-1)) {
    $eidx = scalar(@src_file_names)-1;
  } else {
    $eidx = $sidx + $share - 1;
  }

  my @badly_copied = ();
  for (my $idx = $sidx; $idx<=$eidx; ++$idx) {
    system("adb pull @src_file_names[$idx] @dest_file_names[$idx] ".
           "2> /dev/null");
    my $md5android_line = `adb shell md5 @src_file_names[$idx]`;
    my @md5android_parts = split(" ", $md5android_line);
    my $md5android = $md5android_parts[0];
    my $md5host_line = `md5sum @dest_file_names[$idx]`;
    my @md5host_parts = split(" ", $md5host_line);
    my $md5host = $md5host_parts[0];

    $done = floor(100*($idx-$sidx)/$share);
    if (($done % 2) == 0) {
      print("Thread $thread_count: $done%\n");
    }

    if($md5android ne $md5host){
      push(@badly_copied,@src_file_names[$idx]);
    }
  }

  if (scalar(@badly_copied) > 0) {
    my $s = "Thread $thread_count:\n The following files were badly copied:";
    print($s."\n");
    foreach $bad (@badly_copied){
      print("$bad\n");
    }
  } else {
    my $s = "Thread $thread_count: all files were copied correctly";
    print($s."\n");
  }

  return $thread_count;
}

# Worker subroutine that produces a video file from superframes.
sub subEncode {
  my $thread_count = shift;
  my $nthreads = shift;
  my $device = shift;

  my $share = floor(scalar(@datasets_dest_dirs)/$nthreads);
  my $sidx = ($thread_count * $share);

  if ($thread_count == ($nthreads-1)) {
    $eidx = scalar(@datasets_dest_dirs)-1;
  } else {
    $eidx = $sidx + $share - 1;
  }

  for (my $idx = $sidx; $idx<=$eidx; ++$idx) {
    my $ls_output =
       `ls $dest_path/@datasets_dest_dirs[$idx]/$sf_dir_name/*.pgm 2>/dev/null`;
    if ($ls_output ne ""){
      print("Device $device converting frames to jpeg\n");
      system("mogrify -format jpg $dest_path/@datasets_dest_dirs[$idx]".
             "/$sf_dir_name/*.pgm");
      print("Device $device encoding video: @datasets_dest_dirs[$idx]".
            ".avi\n");
      system("mencoder \"mf://$dest_path/@datasets_dest_dirs[$idx]".
             "/$sf_dir_name/*.jpg\" -o $dest_path/@datasets_dest_dirs[$idx]".
             "/@datasets_dest_dirs[$idx].mp4 -ovc x264 1>/dev/null 2>/dev/null");
      system("rm $dest_path/@datasets_dest_dirs[$idx]/$sf_dir_name/*.jpg");
    } else {
      $msg = "Warning: the dataset @datasets_dest_dirs[$idx] ".
             "does not contain any frame!";
      print($msg."\n");
    }
  }
}

# Prints cl help.
sub usage {
  print("$tmp Usage:\n  adbfastpull [-v -h -o<path> -n<note>]".
        "<dataset_folder> \n    -o<path> destination_path\n    ".
        "-n<note> pull only datasets with this string as note\n    ".
        "-v generate video\n    ".
        "-h this help\n");
}
